package cn.edu.buaa.act.sdp.malwaredetector.util;

import android.annotation.TargetApi;
import android.app.ActivityManager;
import android.content.Context;
import android.content.pm.IPackageStatsObserver;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageStats;
import android.os.Build;
import android.os.Environment;
import android.os.Looper;
import android.os.RemoteException;
import android.widget.Toast;

import java.io.File;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;

import cn.edu.buaa.act.sdp.malwaredetector.entity.PackageInfoWithSize;

/**
 * Created by yao on 2014/11/5.
 * applicatin manager
 */
public class ApplicationManager {
    private static List<PackageInfoWithSize> list = new ArrayList<PackageInfoWithSize>();
    /**
     * get all installed applications
     * @param context
     * @return installed applications list
     */
    public static List<PackageInfoWithSize> getAllInstalledApps(Context context) {
        List<PackageInfo> apps = context.getPackageManager().getInstalledPackages(0);
        list.clear();
        for(PackageInfo pkg : apps) {
            if((pkg.applicationInfo.flags & pkg.applicationInfo.FLAG_SYSTEM) <= 0) {
                list.add(new PackageInfoWithSize(context, pkg));
            }
        }
        return list;
    }

    /**
     * 指定APK的路径，获取PackageInfo
     * @param context
     * @param apkPath: APK的路径
     * @return
     */
    public static PackageInfo getPackageInfo(Context context, String apkPath) {
        PackageInfo pkg = context.getPackageManager().getPackageArchiveInfo(apkPath, PackageManager.GET_ACTIVITIES);
        return pkg;
    }

    /**
     * 搜索整个文件系统查找APK安装包
     * @param context
     * @return APK安装包的PackageInfo列表
     */
    public static List<PackageInfoWithSize> getAllApk(Context context) {
        list.clear();
        File file = Environment.getExternalStorageDirectory();
        getAllApkDFS(context, file);
        return list;
    }

    public static void getAllApkDFS(Context context, File file) {
        if(file.isFile()) {
            String name = file.getName();
            String apkPath = null;
            if(name.toLowerCase().endsWith(".apk")) {
                apkPath = file.getAbsolutePath();
                list.add(new PackageInfoWithSize(context, getPackageInfo(context, apkPath)));
            }
        }
        else {
            File[] files = file.listFiles();
            if(files != null && files.length > 0) {
                for(File fileInFolder : files) {
                    getAllApkDFS(context, fileInFolder);
                }
            }
        }
    }

//    private static PackageStats ps;
//    public static PackageStats getPackageStats(Context context, String packageName) {
//        try {
//            Context mmsContext = context.createPackageContext("com.android.settings",
//                    Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY);
//            Class<?> maClass = Class.forName("com.android.settings.ManageApplications",
//                    true, mmsContext.getClassLoader());
//            Object maObject = maClass.newInstance();
//            Field f_mPm = maClass.getDeclaredField("mPm");
//            f_mPm.setAccessible(true);
//            f_mPm.set(maObject, mmsContext.getPackageManager());
//
//            Field f_mHandler = maClass.getDeclaredField("mHandler");
//            f_mHandler.setAccessible(true);
//            f_mHandler.set(maObject, new Handler(){
//                public void handlerMessage(Message msg) {
//                    if(msg.what == 1) {
//                        ps = (PackageStats) msg.getData().getParcelable("ApplicationPackageStats");
//                    }
//                }
//            });
//
//            Class<?> sizeObserverClass = Class.forName("com.android.settings.ManageApplications$SizeObserver",
//                    true, mmsContext.getClassLoader());
//            Constructor sizeObserverConstructor = sizeObserverClass.getDeclaredConstructors()[0];
//            sizeObserverConstructor.setAccessible(true);
//            Object soObject = sizeObserverConstructor.newInstance(maObject, 1);
//            sizeObserverClass.getMethod("invokeGetSize", String.class, CountDownLatch.class).invoke(soObject, packageName, new CountDownLatch(1));
//
//        } catch (PackageManager.NameNotFoundException e) {
//            e.printStackTrace();
//        } catch (ClassNotFoundException e) {
//            e.printStackTrace();
//        } catch (InstantiationException e) {
//            e.printStackTrace();
//        } catch (IllegalAccessException e) {
//            e.printStackTrace();
//        } catch (NoSuchFieldException e) {
//            e.printStackTrace();
//        } catch (NoSuchMethodException e) {
//            e.printStackTrace();
//        } catch (InvocationTargetException e) {
//            e.printStackTrace();
//        }
//        return ps;
//    }

    public static long getPackageSize(Context context, final String packageName) {
        final long[] size = {0};
        try {
            Method method = PackageManager.class.getMethod("getPackageSizeInfo",
                    new Class[] {String.class, IPackageStatsObserver.class});
            method.invoke(context.getPackageManager(), new Object[]{
                    packageName,
                    new IPackageStatsObserver.Stub() {
                        @Override
                        public void onGetStatsCompleted(PackageStats pStats, boolean succeeded) throws RemoteException {
                            size[0] = pStats.cacheSize + pStats.codeSize + pStats.cacheSize + pStats.externalCacheSize;
                        }
                    }
            });
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        return size[0];
    }

    public static List<ActivityManager.RunningAppProcessInfo> getRunningAppProcessInfo(Context context) {
        ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
        List<ActivityManager.RunningAppProcessInfo> runningAppProcessInfos = activityManager.getRunningAppProcesses();
        return runningAppProcessInfos;
    }
}
